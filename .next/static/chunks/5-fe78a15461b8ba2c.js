"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[5],{9600:function(e,n,t){t.d(n,{bd:function(){return r},tI:function(){return getQuestions},xL:function(){return addQuestion}}),t(2265);let r=[{name:"Arrays",subcategories:["1D Arrays","2D Arrays","Sliding Window","Two Pointers"]},{name:"Strings",subcategories:["Basic","Pattern Matching","Window"]},{name:"Linked List",subcategories:["Singly","Doubly","Circular"]},{name:"Stacks & Queues"},{name:"Trees",subcategories:["Binary Trees","Binary Search Trees","Heaps"]},{name:"Graphs",subcategories:["DFS","BFS","Topological Sort"]},{name:"Dynamic Programming"},{name:"Greedy"},{name:"Recursion"},{name:"Backtracking"},{name:"Bit Manipulation"}],i=[{id:1,category:"Arrays",subcategory:"1D Arrays",difficulty:"Easy",title:"Two Sum",problem:"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",solution:"Use a hash map to store complements and find the solution in one pass.",code:"function twoSum(nums: number[], target: number): number[] {\n      const map = new Map();\n      for (let i = 0; i < nums.length; i++) {\n        const complement = target - nums[i];\n        if (map.has(complement)) {\n          return [map.get(complement), i];\n        }\n        map.set(nums[i], i);\n      }\n      return [];\n    }",timeComplexity:"O(n)",spaceComplexity:"O(n)",tags:["Hash Table","Array"],sampleInput:"nums = [2,7,11,15], target = 9",sampleOutput:"[0,1]"},{id:2,category:"Arrays",subcategory:"Sliding Window",difficulty:"Medium",title:"Longest Substring Without Repeating Characters",problem:"Given a string s, find the length of the longest substring without repeating characters.",solution:"Use a sliding window approach with a hash set to keep track of characters in the current window.",code:"function lengthOfLongestSubstring(s: string): number {\n      let maxLength = 0;\n      let start = 0;\n      const charSet = new Set();\n\n      for (let end = 0; end < s.length; end++) {\n        while (charSet.has(s[end])) {\n          charSet.delete(s[start]);\n          start++;\n        }\n        charSet.add(s[end]);\n        maxLength = Math.max(maxLength, end - start + 1);\n      }\n\n      return maxLength;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(min(m,n))",tags:["Hash Table","String","Sliding Window"],sampleInput:'s = "abcabcbb"',sampleOutput:"3"},{id:3,category:"Arrays",subcategory:"Binary Search",difficulty:"Medium",title:"Binary Search",problem:"Given a sorted array of integers, find the index of a target element using binary search.",solution:"Use binary search to efficiently find the target in the sorted array by halving the search range in each step.",code:"function binarySearch(arr: number[], target: number): number {\n      let left = 0;\n      let right = arr.length - 1;\n\n      while (left <= right) {\n        const mid = Math.floor((left + right) / 2);\n\n        if (arr[mid] === target) {\n          return mid;\n        } else if (arr[mid] < target) {\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n      }\n\n      return -1; // Target not found\n    }",timeComplexity:"O(log n)",spaceComplexity:"O(1)",tags:["Binary Search","Array"],sampleInput:"arr = [1, 2, 3, 4, 5], target = 3",sampleOutput:"2"},{id:4,category:"Strings",subcategory:"Basic",difficulty:"Easy",title:"Reverse String",problem:"Write a function that reverses a string.",solution:"Iterate through the string from the end to the start and build a new string.",code:"function reverseString(s: string): string {\n      let result = '';\n      for (let i = s.length - 1; i >= 0; i--) {\n        result += s[i];\n      }\n      return result;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(n)",tags:["String"],sampleInput:'s = "hello"',sampleOutput:'"olleh"'},{id:5,category:"Linked List",subcategory:"Singly",difficulty:"Medium",title:"Reverse Linked List",problem:"Given a singly linked list, reverse the list.",solution:"Use three pointers (prev, current, next) to reverse the links in the list.",code:"function reverseLinkedList(head: ListNode | null): ListNode | null {\n      let prev = null;\n      let current = head;\n\n      while (current !== null) {\n        let next = current.next;\n        current.next = prev;\n        prev = current;\n        current = next;\n      }\n\n      return prev;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(1)",tags:["Linked List"],sampleInput:"head = [1, 2, 3, 4, 5]",sampleOutput:"[5, 4, 3, 2, 1]"},{id:6,category:"Stacks & Queues",difficulty:"Medium",title:"Valid Parentheses",problem:'Given a string containing just the characters "(", ")", "{", "}", "[", "]", determine if the input string is valid.',solution:"Use a stack to keep track of opening parentheses and match them with closing parentheses.",code:"function isValid(s: string): boolean {\n      const stack: string[] = [];\n      const map = {\n        '(': ')',\n        '{': '}',\n        '[': ']',\n      };\n\n      for (let char of s) {\n        if (map[char]) {\n          stack.push(char);\n        } else if (Object.values(map).includes(char)) {\n          if (map[stack.pop()] !== char) {\n            return false;\n          }\n        }\n      }\n\n      return stack.length === 0;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(n)",tags:["Stack","Parentheses"],sampleInput:'s = "()"',sampleOutput:"true"},{id:7,category:"Trees",subcategory:"Binary Trees",difficulty:"Medium",title:"Inorder Traversal of Binary Tree",problem:"Given a binary tree, return the inorder traversal of its nodes' values.",solution:"Use recursion or stack to traverse the tree in inorder.",code:"function inorderTraversal(root: TreeNode | null): number[] {\n      const result: number[] = [];\n      function inorder(node: TreeNode | null) {\n        if (node === null) return;\n        inorder(node.left);\n        result.push(node.val);\n        inorder(node.right);\n      }\n      inorder(root);\n      return result;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(n)",tags:["Binary Tree","Traversal"],sampleInput:"root = [1,null,2,3]",sampleOutput:"[1, 3, 2]"},{id:8,category:"Graphs",subcategory:"DFS",difficulty:"Medium",title:"Number of Islands",problem:'Given a 2D grid of "1"s (land) and "0"s (water), count the number of islands.',solution:"Use Depth First Search (DFS) to explore each island and mark visited cells.",code:"function numIslands(grid: string[][]): number {\n      const rows = grid.length;\n      const cols = grid[0].length;\n      let count = 0;\n\n      function dfs(r: number, c: number) {\n        if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] === '0') return;\n        grid[r][c] = '0'; // Mark the cell as visited\n        dfs(r - 1, c); // up\n        dfs(r + 1, c); // down\n        dfs(r, c - 1); // left\n        dfs(r, c + 1); // right\n      }\n\n      for (let r = 0; r < rows; r++) {\n        for (let c = 0; c < cols; c++) {\n          if (grid[r][c] === '1') {\n            count++;\n            dfs(r, c);\n          }\n        }\n      }\n\n      return count;\n    }",timeComplexity:"O(m * n)",spaceComplexity:"O(m * n)",tags:["DFS","Graph"],sampleInput:'grid = [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]]',sampleOutput:"1"},{id:9,category:"Dynamic Programming",difficulty:"Medium",title:"Climbing Stairs",problem:"You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you reach the top?",solution:"Use dynamic programming to solve this problem by calculating the number of ways to reach each step.",code:"function climbStairs(n: number): number {\n      if (n <= 2) return n;\n      let first = 1;\n      let second = 2;\n      \n      for (let i = 3; i <= n; i++) {\n        const temp = first + second;\n        first = second;\n        second = temp;\n      }\n      \n      return second;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(1)",tags:["Dynamic Programming"],sampleInput:"n = 3",sampleOutput:"3"},{id:10,category:"Arrays",subcategory:"2D Arrays",difficulty:"Medium",title:"Rotate Image",problem:"You are given an n x n 2D matrix representing an image. Rotate the image by 90 degrees (clockwise).",solution:"Transpose the matrix and then reverse each row.",code:"function rotate(matrix: number[][]): void {\n      const n = matrix.length;\n      // Transpose the matrix\n      for (let i = 0; i < n; i++) {\n        for (let j = i; j < n; j++) {\n          [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n        }\n      }\n      // Reverse each row\n      for (let i = 0; i < n; i++) {\n        matrix[i].reverse();\n      }\n    }",timeComplexity:"O(n^2)",spaceComplexity:"O(1)",tags:["Matrix","Array"],sampleInput:"matrix = [[1,2,3],[4,5,6],[7,8,9]]",sampleOutput:"[[7,4,1],[8,5,2],[9,6,3]]"},{id:11,category:"Strings",subcategory:"Pattern Matching",difficulty:"Medium",title:"KMP Pattern Matching",problem:"Implement the KMP (Knuth-Morris-Pratt) string matching algorithm to find the first occurrence of a pattern in a string.",solution:"Use the partial match table (LPS array) to skip unnecessary comparisons.",code:"function kmpPatternMatching(text: string, pattern: string): number {\n      const lps: number[] = buildLpsArray(pattern);\n      let i = 0, j = 0;\n      \n      while (i < text.length) {\n        if (text[i] === pattern[j]) {\n          i++;\n          j++;\n        }\n        \n        if (j === pattern.length) {\n          return i - j; // Match found\n        } else if (i < text.length && text[i] !== pattern[j]) {\n          if (j !== 0) {\n            j = lps[j - 1];\n          } else {\n            i++;\n          }\n        }\n      }\n      \n      return -1; // No match\n    }\n    \n    function buildLpsArray(pattern: string): number[] {\n      const lps: number[] = [0];\n      let length = 0, i = 1;\n      \n      while (i < pattern.length) {\n        if (pattern[i] === pattern[length]) {\n          length++;\n          lps[i] = length;\n          i++;\n        } else {\n          if (length !== 0) {\n            length = lps[length - 1];\n          } else {\n            lps[i] = 0;\n            i++;\n          }\n        }\n      }\n      return lps;\n    }",timeComplexity:"O(n + m)",spaceComplexity:"O(m)",tags:["Pattern Matching","String"],sampleInput:'text = "ABABDABACDABABCABAB", pattern = "ABABCABAB"',sampleOutput:"10"},{id:12,category:"Linked List",subcategory:"Doubly",difficulty:"Medium",title:"Flatten a Doubly Linked List",problem:"Given a doubly linked list, flatten it so that all the nodes appear in a single-level doubly linked list.",solution:"Use recursion to flatten the sublists while maintaining the structure of the doubly linked list.",code:"function flatten(head: Node | null): Node | null {\n      if (!head) return null;\n\n      let current = head;\n      while (current) {\n        if (current.child) {\n          const child = current.child;\n          current.child = null;\n\n          let temp = current.next;\n          current.next = child;\n          child.prev = current;\n\n          while (child.next) child = child.next;\n          child.next = temp;\n          if (temp) temp.prev = child;\n        }\n        current = current.next;\n      }\n\n      return head;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(1)",tags:["Doubly Linked List"],sampleInput:"head = [1,2,3,null,null,4,5]",sampleOutput:"[1,2,3,4,5]"},{id:13,category:"Stacks & Queues",difficulty:"Easy",title:"Implement Stack Using Queues",problem:"Implement a stack using two queues.",solution:"Use two queues: one to store elements and the other to perform operations.",code:"class MyStack {\n      private queue1: number[] = [];\n      private queue2: number[] = [];\n\n      push(x: number): void {\n        this.queue1.push(x);\n      }\n\n      pop(): number {\n        while (this.queue1.length > 1) {\n          this.queue2.push(this.queue1.shift()!);\n        }\n        const poppedElement = this.queue1.shift()!;\n        [this.queue1, this.queue2] = [this.queue2, this.queue1]; // Swap the queues\n        return poppedElement;\n      }\n\n      top(): number {\n        return this.queue1[this.queue1.length - 1];\n      }\n\n      empty(): boolean {\n        return this.queue1.length === 0;\n      }\n    }",timeComplexity:"O(n) for pop, O(1) for push",spaceComplexity:"O(n)",tags:["Queue","Stack"],sampleInput:"stack.push(1), stack.push(2), stack.pop()",sampleOutput:"2"},{id:14,category:"Trees",subcategory:"Binary Search Trees",difficulty:"Hard",title:"Validate Binary Search Tree",problem:"Given a binary tree, determine if it is a valid binary search tree.",solution:"Use recursion with bounds to check if the tree adheres to BST properties.",code:"function isValidBST(root: TreeNode | null): boolean {\n      function helper(node: TreeNode | null, lower: number | null, upper: number | null): boolean {\n        if (!node) return true;\n        \n        const val = node.val;\n        if (lower !== null && val <= lower) return false;\n        if (upper !== null && val >= upper) return false;\n        \n        if (!helper(node.left, lower, val)) return false;\n        if (!helper(node.right, val, upper)) return false;\n        \n        return true;\n      }\n\n      return helper(root, null, null);\n    }",timeComplexity:"O(n)",spaceComplexity:"O(h)",tags:["Binary Search Tree","Tree"],sampleInput:"root = [2,1,3]",sampleOutput:"true"},{id:15,category:"Graphs",subcategory:"BFS",difficulty:"Medium",title:"Word Ladder",problem:"Given two words beginWord and endWord, and a dictionary, find the length of the shortest transformation sequence from beginWord to endWord, such that only one letter can be changed at a time and each transformed word must exist in the dictionary.",solution:"Use breadth-first search (BFS) to explore the word transformations.",code:"function ladderLength(beginWord: string, endWord: string, wordList: string[]): number {\n      const wordSet = new Set(wordList);\n      if (!wordSet.has(endWord)) return 0;\n      \n      let queue: [string, number][] = [[beginWord, 1]]; // word, level\n      while (queue.length > 0) {\n        const [word, level] = queue.shift()!;\n        \n        for (let i = 0; i < word.length; i++) {\n          const newWord = word.slice(0, i) + '*' + word.slice(i + 1);\n          for (let candidate of wordSet) {\n            if (candidate === newWord && candidate !== word) {\n              if (candidate === endWord) return level + 1;\n              queue.push([candidate, level + 1]);\n              wordSet.delete(candidate);\n            }\n          }\n        }\n      }\n      \n      return 0;\n    }",timeComplexity:"O(n * m)",spaceComplexity:"O(n * m)",tags:["Graph","BFS"],sampleInput:'beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]',sampleOutput:"5"},{id:16,category:"Backtracking",subcategory:"Combinations",difficulty:"Medium",title:"Combinations of N and K",problem:"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].",solution:"Use recursion to generate combinations by building up the combination incrementally.",code:"function combine(n: number, k: number): number[][] {\n      const result: number[][] = [];\n      \n      function backtrack(start: number, current: number[]) {\n        if (current.length === k) {\n          result.push([...current]);\n          return;\n        }\n        \n        for (let i = start; i <= n; i++) {\n          current.push(i);\n          backtrack(i + 1, current);\n          current.pop();\n        }\n      }\n      \n      backtrack(1, []);\n      return result;\n    }",timeComplexity:"O(n choose k)",spaceComplexity:"O(k)",tags:["Backtracking","Combinations"],sampleInput:"n = 4, k = 2",sampleOutput:"[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]"},{id:17,category:"Backtracking",subcategory:"Permutations",difficulty:"Medium",title:"Permutations of Unique Numbers",problem:"Given an array of unique integers, return all possible permutations.",solution:"Use recursion to generate all possible permutations by swapping elements in the array.",code:"function permute(nums: number[]): number[][] {\n      const result: number[][] = [];\n      \n      function backtrack(start: number) {\n        if (start === nums.length) {\n          result.push([...nums]);\n          return;\n        }\n        \n        for (let i = start; i < nums.length; i++) {\n          [nums[start], nums[i]] = [nums[i], nums[start]]; // Swap\n          backtrack(start + 1);\n          [nums[start], nums[i]] = [nums[i], nums[start]]; // Swap back\n        }\n      }\n      \n      backtrack(0);\n      return result;\n    }",timeComplexity:"O(n!)",spaceComplexity:"O(n)",tags:["Backtracking","Permutations"],sampleInput:"nums = [1,2,3]",sampleOutput:"[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"},{id:18,category:"Recursion",subcategory:"Tree Traversal",difficulty:"Easy",title:"Preorder Traversal of Binary Tree",problem:"Given the root of a binary tree, return the preorder traversal of its nodes' values.",solution:"Use recursion to traverse the tree in preorder (root, left, right).",code:"function preorderTraversal(root: TreeNode | null): number[] {\n      const result: number[] = [];\n      \n      function dfs(node: TreeNode | null) {\n        if (!node) return;\n        \n        result.push(node.val);\n        dfs(node.left);\n        dfs(node.right);\n      }\n      \n      dfs(root);\n      return result;\n    }",timeComplexity:"O(n)",spaceComplexity:"O(n)",tags:["Tree","Recursion","Preorder"],sampleInput:"root = [1,null,2,3]",sampleOutput:"[1,2,3]"},{id:19,category:"Backtracking",subcategory:"Sudoku Solver",difficulty:"Hard",title:"Solve Sudoku",problem:"Write a program to solve a Sudoku puzzle by filling the empty cells.",solution:"Use backtracking to fill the empty cells while checking for valid placements.",code:"function solveSudoku(board: string[][]): void {\n      function isValid(board: string[][], row: number, col: number, num: string): boolean {\n        for (let i = 0; i < 9; i++) {\n          if (board[row][i] === num || board[i][col] === num) return false;\n        }\n        \n        const startRow = Math.floor(row / 3) * 3;\n        const startCol = Math.floor(col / 3) * 3;\n        for (let i = startRow; i < startRow + 3; i++) {\n          for (let j = startCol; j < startCol + 3; j++) {\n            if (board[i][j] === num) return false;\n          }\n        }\n        \n        return true;\n      }\n      \n      function backtrack(board: string[][]): boolean {\n        for (let row = 0; row < 9; row++) {\n          for (let col = 0; col < 9; col++) {\n            if (board[row][col] === '.') {\n              for (let num = 1; num <= 9; num++) {\n                const strNum = num.toString();\n                if (isValid(board, row, col, strNum)) {\n                  board[row][col] = strNum;\n                  if (backtrack(board)) return true;\n                  board[row][col] = '.'; // Backtrack\n                }\n              }\n              return false; // No valid number found\n            }\n          }\n        }\n        return true; // Solved\n      }\n      \n      backtrack(board);\n    }",timeComplexity:"O(9^(m*n))",spaceComplexity:"O(m*n)",tags:["Backtracking","Sudoku"],sampleInput:'board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".","",".",".","8",".",".","7","9"],[".","8",".",".",".",".",".","2","5"]] ',sampleOutput:'[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]] '},{id:20,category:"Recursion",subcategory:"Fibonacci",difficulty:"Easy",title:"Fibonacci Sequence",problem:"Write a function to compute the nth Fibonacci number using recursion.",solution:"Use the recursive definition of Fibonacci to calculate the result.",code:"function fib(n: number): number {\n      if (n <= 1) return n;\n      return fib(n - 1) + fib(n - 2);\n    }",timeComplexity:"O(2^n)",spaceComplexity:"O(n)",tags:["Recursion","Fibonacci"],sampleInput:"n = 5",sampleOutput:"5"},{id:21,category:"Backtracking",subcategory:"N-Queens",difficulty:"Hard",title:"N-Queens Problem",problem:"Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution is represented as a 2D board where queens are placed on different rows, and no two queens can share the same column or diagonal.",solution:"Use backtracking to try placing queens row by row while checking for valid positions.",code:"function solveNQueens(n: number): string[][] {\n      const result: string[][] = [];\n      const board: string[] = Array(n).fill('.'.repeat(n));\n      \n      function isValid(board: string[], row: number, col: number): boolean {\n        for (let i = 0; i < row; i++) {\n          if (board[i][col] === 'Q') return false;\n          if (col - (row - i) >= 0 && board[i][col - (row - i)] === 'Q') return false;\n          if (col + (row - i) < n && board[i][col + (row - i)] === 'Q') return false;\n        }\n        return true;\n      }\n\n      function backtrack(row: number) {\n        if (row === n) {\n          result.push([...board]);\n          return;\n        }\n\n        for (let col = 0; col < n; col++) {\n          if (isValid(board, row, col)) {\n            board[row] = board[row].slice(0, col) + 'Q' + board[row].slice(col + 1);\n            backtrack(row + 1);\n            board[row] = board[row].slice(0, col) + '.' + board[row].slice(col + 1);\n          }\n        }\n      }\n\n      backtrack(0);\n      return result;\n    }",timeComplexity:"O(n!)",spaceComplexity:"O(n)",tags:["Backtracking","N-Queens"],sampleInput:"n = 4",sampleOutput:'[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]] '},{id:29,category:"Bit Manipulation",subcategory:"Advanced Operations",difficulty:"Hard",title:"Find the Two Non-Repeated Numbers",problem:"Given an array of integers where every element appears twice except for two, find the two elements that appear only once.",solution:"Use XOR to find the combined XOR of the two unique elements, then use bit manipulation to separate them based on the set bit.",code:"function singleNumber(nums: number[]): number[] {\n      let xor = 0;\n      for (const num of nums) {\n        xor ^= num; // XOR all elements together\n      }\n\n      const rightmostSetBit = xor & (-xor); // Find rightmost set bit\n      let num1 = 0, num2 = 0;\n\n      for (const num of nums) {\n        if (num & rightmostSetBit) {\n          num1 ^= num; // Group 1\n        } else {\n          num2 ^= num; // Group 2\n        }\n      }\n\n      return [num1, num2];\n    }",timeComplexity:"O(n)",spaceComplexity:"O(1)",tags:["Bit Manipulation","XOR"],sampleInput:"nums = [1, 2, 1, 3, 2, 5]",sampleOutput:"[3, 5]"}],getQuestions=async()=>(await new Promise(e=>setTimeout(e,1e3)),i),addQuestion=async e=>{await new Promise(e=>setTimeout(e,1e3));let n=i.length+1;i=[...i,{id:n,...e}]}},3611:function(e,n,t){t.d(n,{z:function(){return u}});var r=t(7437),i=t(2265),o=t(3474),a=t(6061),s=t(1628);let l=(0,a.j)("inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),u=i.forwardRef((e,n)=>{let{className:t,variant:i,size:a,asChild:u=!1,...c}=e,d=u?o.g7:"button";return(0,r.jsx)(d,{className:(0,s.cn)(l({variant:i,size:a,className:t})),ref:n,...c})});u.displayName="Button"},5831:function(e,n,t){t.d(n,{I:function(){return a}});var r=t(7437),i=t(2265),o=t(1628);let a=i.forwardRef((e,n)=>{let{className:t,type:i,...a}=e;return(0,r.jsx)("input",{type:i,className:(0,o.cn)("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",t),ref:n,...a})});a.displayName="Input"},7532:function(e,n,t){t.d(n,{Bw:function(){return m},Ph:function(){return u},Ql:function(){return f},i4:function(){return d},ki:function(){return c}});var r=t(7437),i=t(2265),o=t(6565),a=t(3523),s=t(2442),l=t(1628);let u=o.fC;o.ZA;let c=o.B4,d=i.forwardRef((e,n)=>{let{className:t,children:i,...s}=e;return(0,r.jsxs)(o.xz,{ref:n,className:(0,l.cn)("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",t),...s,children:[i,(0,r.jsx)(o.JO,{asChild:!0,children:(0,r.jsx)(a.Z,{className:"h-4 w-4 opacity-50"})})]})});d.displayName=o.xz.displayName;let m=i.forwardRef((e,n)=>{let{className:t,children:i,position:a="popper",...s}=e;return(0,r.jsx)(o.h_,{children:(0,r.jsx)(o.VY,{ref:n,className:(0,l.cn)("relative z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2","popper"===a&&"data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",t),position:a,...s,children:(0,r.jsx)(o.l_,{className:(0,l.cn)("p-1","popper"===a&&"h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"),children:i})})})});m.displayName=o.VY.displayName;let p=i.forwardRef((e,n)=>{let{className:t,...i}=e;return(0,r.jsx)(o.__,{ref:n,className:(0,l.cn)("py-1.5 pl-8 pr-2 text-sm font-semibold",t),...i})});p.displayName=o.__.displayName;let f=i.forwardRef((e,n)=>{let{className:t,children:i,...a}=e;return(0,r.jsxs)(o.ck,{ref:n,className:(0,l.cn)("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",t),...a,children:[(0,r.jsx)("span",{className:"absolute left-2 flex h-3.5 w-3.5 items-center justify-center",children:(0,r.jsx)(o.wU,{children:(0,r.jsx)(s.Z,{className:"h-4 w-4"})})}),(0,r.jsx)(o.eT,{children:i})]})});f.displayName=o.ck.displayName;let g=i.forwardRef((e,n)=>{let{className:t,...i}=e;return(0,r.jsx)(o.Z0,{ref:n,className:(0,l.cn)("-mx-1 my-1 h-px bg-muted",t),...i})});g.displayName=o.Z0.displayName},2147:function(e,n,t){t.d(n,{g:function(){return a}});var r=t(7437),i=t(2265),o=t(1628);let a=i.forwardRef((e,n)=>{let{className:t,...i}=e;return(0,r.jsx)("textarea",{className:(0,o.cn)("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",t),ref:n,...i})});a.displayName="Textarea"},1628:function(e,n,t){t.d(n,{cn:function(){return cn}});var r=t(348),i=t(3986);function cn(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return(0,i.m)((0,r.W)(n))}}}]);